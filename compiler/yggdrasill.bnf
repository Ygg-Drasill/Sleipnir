<<
import (
    "github.com/Ygg-Drasill/Sleipnir/compiler/gocc/util"
    "github.com/Ygg-Drasill/Sleipnir/compiler/gocc/token"
    "github.com/Ygg-Drasill/Sleipnir/compiler/ast"
)
>>

/* Production rules */

/* Outer file scope */
ProgramDeclarationLst
    : NodeLst ConnLst   << ast.NewProgram($0, $1) >>
    ;

Node
    : "node" nodeId "{" NodeIn NodeOut NodeProc "}"     << ast.NewNode($Context, $1, $3, $4, $5) >>
    ;

Conn
    : ConnOut "->" ConnIn stmtEnd       << ast.NewConnection($0, $2) >>
    ;

ConnOut
    : nodeId "." out "." varId          << ast.NewJunction($0, $4) >>
    | nodeId "." out                    << ast.NewJunction($0, "") >>
    ;

ConnIn
    : nodeId "." in "." varId           << ast.NewJunction($0, $4) >>
    | nodeId "." in                     << ast.NewJunction($0, "") >>
    ;

NodeLst
    : Node          << ast.NewNodeList($0) >>
    | Node NodeLst  << ast.AppendNode($1, $0) >>
    ;

ConnLst
    : Conn          << ast.NewConnectionList($0) >>
    | Conn ConnLst  << ast.AppendConnection($1, $0) >>
    ;

/* Node scope */
Type : "int" | "bool" | "string" ;

NodeVar  : in "." varId     << ast.NewNodeVar($0, $2) >>
         | out "." varId    << ast.NewNodeVar($0, $2) >>
         | varId
         ;


NodeIn
    : in "{" DeclarationLst "}" << ast.NewScopeIn($Context, $2) >>
    | empty
    ;

NodeOut
    : out "{" DeclarationLst "}" << ast.NewScopeOut($Context, $2) >>
    | empty
    ;

NodeProc
    : "process" "{" StmtLst "}" << ast.NewScopeProc($Context, $2) >>
    | "process" "{" "}"         << ast.NewScopeProc($Context, nil) >>
    | empty
    ;

/* Statement productions */
DeclarationStmt
    	: Type varId stmtEnd                << ast.NewDeclaration($0, $1, nil, $Context) >>
    	| Type varId Assignment stmtEnd     << ast.NewDeclaration($0, $1, $2, $Context) >>
    	;

DeclarationLst
    	: DeclarationStmt DeclarationLst    << ast.AppendDeclaration($1, $0) >>
    	| DeclarationStmt                   << ast.NewDeclarationList($0) >>
	    ;

Condition
    	: LogicalExpr logicOp Condition
    	| LogicalExpr
    	;

Assignment : assignOp Expr ;

AssignStmt : NodeVar Assignment stmtEnd ;

ControlStmt: IfStmt | WhileStmt ;

IfStmt
    : "if" "(" Condition ")" "{" StmtLst "}"  << ast.NewIfStatement($2, $5, nil) >>
    | "if" "(" Condition ")" "{" StmtLst "}" "else" "{" StmtLst "}"  << ast.NewIfStatement($2, $5, $9) >>
    ;

WhileStmt
    : "while" "(" Condition ")" "{" StmtLst "}" << ast.NewWhileStatement($2, $5) >>
    ;

Stmt
    : DeclarationStmt
    | AssignStmt
    | ControlStmt
    ;

StmtLst
    : Stmt StmtLst  << ast.AppendStatement($1, $0) >>
    | Stmt          << ast.NewStatementList($0) >>
    | empty
    ;


/* Expressions */
Expr
    : AritExpr              << $0, nil >>
    | LogicalExpr           << $0, nil >>
    ;

LogicalExpr
    : NodeVar compOp NodeVar    << ast.NewExpression($0, $1, $2) >>
    ;

AritExpr
    : AritExpr "+" Term     << ast.NewExpression($0, $1, $2) >>
    | AritExpr "-" Term     << ast.NewExpression($0, $1, $2) >>
    | Term
    ;

Term
    : Term "*" Factor       << ast.NewExpression($0, $1, $2) >>
    | Term "/" Factor       << ast.NewExpression($0, $1, $2) >>
    | Factor
    ;

Factor
    : int64 						<< util.IntValue($0.(*token.Token).Lit) >>
    | NodeVar
    ;
